#!/bin/bash
set -eu

die()
{
	local r=$1
	shift
	# shellcheck disable=SC2059
	printf "$@"
	exit "$r"
}

find_channel()
{
	declare -n channels=$1
	local channel=$2
	local out=$3
	local i other_channel

	for i in "${!channels[@]}"; do
		read_channel_name "${channels[$i]}" other_channel
		# $channel can be a pattern:
		# shellcheck disable=SC2053
		if [[ $other_channel == $channel ]]; then
			local "$out" && upvar "$out" "$i"
			return 0
		fi
	done

	return 1
}

is_sd_duplicate()
{
	local channel=$1
	local other_channel

	for channel_line in "${channel_lines[@]}"; do
		read_channel_name "$channel_line" other_channel
		[[ $channel != "$other_channel" ]] || continue

		if [[ "$channel HD" == "$other_channel" ||
			($other_channel == *" HD "* && $channel == "${other_channel/ HD/}") ]]; then
			return 0
		fi
	done
	return 1
}

is_unwanted()
{
	local channel=$1

	for unwanted_channel in "${unwanted_channels[@]}"; do
		# $unwanted_channel can be a pattern:
		# shellcheck disable=SC2053
		if [[ ${unwanted_channel:0:1} != '#' && $channel == $unwanted_channel ]]; then
			return 0
		fi
	done
	return 1
}

read_channel_name()
{
	local name=${1%%:*}
	upvar "$2" "${name%%;*}"
}

upvar()
{
	unset -v "$1" && eval "$1=\"\$2\""
}

usage()
{
	printf "\
Usage: %s CHANNELS_CONF [CHANNEL_ORDER [UNWANTED_CHANNELS]]

Clean SD channels for which an HD channel of same name exists, and optionally
unwanted channels from a channels.conf. The cleaned channels.conf is printed to
standard out.

The path to a channels.conf must be given as the first parameter CHANNELS_CONF.

An optional file with the desired channel order can be given as second
parameter CHANNEL_ORDER. Each line in this list should contain the name of a
channel. The names may contain a * as a wildcard. (Only) the first matching
channel from the channels.conf is placed according to the order. All remaining
channels that were not listed in the channel order are appended in the output.

An optional file with a list of unwanted channels can be given as third
parameter UNWANTED_CHANNELS. Each line in this list should contain the name of
a channel to remove from the output. The names may contain a * as a wildcard.
Lines starting with # are treated as comments and ignored.
" "$0"
}

if [[ $# -eq 0 ]]; then
	usage >&2
	exit 2
fi

[[ $# -le 3 ]] || die 2 "too many arguments\n"
[[ $# -ge 1 ]] || die 2 "missing argument(s)\n"

# We load the complete input channels.conf upfront. The output of this script can
# be redirected to the same file without problems.
mapfile channel_lines <"$1"

channel_order=()
if [[ $# -gt 1 ]]; then
	mapfile -t channel_order <"$2"
fi

unwanted_channels=()
if [[ $# -gt 2 ]]; then
	mapfile -t unwanted_channels <"$3"
fi

num_channels=${#channel_lines[@]}
for ((i = 0; i < num_channels; ++i)); do
	channel=
	read_channel_name "${channel_lines[$i]}" channel
	# Also drop empty or bogus entries:
	if [[ ! $channel || $channel == '???' ]] || is_sd_duplicate "$channel" ||
		is_unwanted "$channel"; then
		unset "channel_lines[$i]"
		continue
	fi
done

sorted_channel_lines=()
for ordered_channel in "${channel_order[@]}"; do
	find_channel channel_lines "$ordered_channel" i || continue
	sorted_channel_lines+=("${channel_lines[$i]}")
	unset "channel_lines[$i]"
done

# Append remaining channels in the order they were discovered:
sorted_channel_lines+=("${channel_lines[@]}")

printf "%s" "${sorted_channel_lines[@]}"
